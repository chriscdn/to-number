{"version":3,"file":"to-number.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * Converts an unknown value to a numeric type (integer or float).\n * `NaN`, `Infinity`, and `-Infinity` are considered non-numeric and return `null`.\n *\n * @param {unknown} input - The value to convert.\n * @returns {number | null} The numeric value, or `null` if conversion fails.\n */\n\nenum RoundingMode {\n  NONE = \"none\",\n  FLOOR = \"floor\",\n  CEIL = \"ceil\",\n  ROUND = \"round\",\n}\n\ntype Options = {\n  roundingMode?: RoundingMode;\n  digits?: number;\n};\n\nconst toNumber = (\n  input: unknown,\n  options?: Options,\n) => {\n  const roundingMode = options?.roundingMode ?? RoundingMode.NONE;\n  const digits = options?.digits ?? 0;\n\n  const cast = isNumber(input) ? input : parseFloat(String(input));\n\n  if (isNumber(cast)) {\n    switch (roundingMode) {\n      case RoundingMode.FLOOR:\n        return floor(cast, { digits });\n      case RoundingMode.CEIL:\n        return ceil(cast, { digits });\n      case RoundingMode.ROUND:\n        return round(cast, { digits });\n      default:\n        return cast;\n    }\n  } else {\n    return null;\n  }\n};\n\nconst toNumberOrThrow = (\n  input: unknown,\n  options?: Options,\n) => {\n  const result = toNumber(input, options);\n\n  if (isNumber(result)) {\n    return result;\n  } else {\n    throw new TypeError(`Cannot convert ${input} to number.`);\n  }\n};\n\nconst toInteger = (input: unknown) =>\n  toNumber(input, {\n    roundingMode: RoundingMode.FLOOR,\n  });\n\nconst toIntegerOrThrow = (input: unknown) =>\n  toNumberOrThrow(input, {\n    roundingMode: RoundingMode.FLOOR,\n  });\n\n/**\n * Rounds a floating-point number to the specified number of decimal digits.\n *\n * @param {number} num - The number to round.\n * @param {{ digits: number }} [options={ digits: 0 }] - An options object specifying the number of decimal digits to keep.\n * @returns {number} The rounded number.\n */\nconst round = (\n  num: number,\n  options: { digits: number } = { digits: 0 },\n) => {\n  const factor = 10 ** options.digits;\n  return Math.round(num * factor) / factor;\n};\n\nconst floor = (\n  num: number,\n  options: { digits: number } = { digits: 0 },\n) => {\n  const factor = 10 ** options.digits;\n  return Math.floor(num * factor) / factor;\n};\n\nconst ceil = (\n  num: number,\n  options: { digits: number } = { digits: 0 },\n) => {\n  const factor = 10 ** options.digits;\n  return Math.ceil(num * factor) / factor;\n};\n\n/**\n * Checks if the given value is an integer.\n *\n * Note: `NaN`, `Infinity`, and `-Infinity` are considered invalid.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is number} True if the value is a finite integer, otherwise false.\n */\nconst isInteger = (value: unknown): value is number =>\n  typeof value === \"number\" && Number.isInteger(value);\n\n/**\n * Checks if the given value is a floating-point number (non-integer).\n *\n * Note: `NaN`, `Infinity`, and `-Infinity` are considered invalid.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is number} True if the value is a finite float, otherwise false.\n */\nconst isFloat = (value: unknown): value is number =>\n  typeof value === \"number\" && !Number.isInteger(value);\n\n/**\n * Checks if the given value is a finite number (integer or float).\n *\n * Note: `NaN`, `Infinity`, and `-Infinity` are considered invalid.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is number} True if the value is a finite number, otherwise false.\n */\nconst isNumber = (value: unknown): value is number =>\n  typeof value === \"number\" && Number.isFinite(value);\n\nexport {\n  ceil,\n  floor,\n  isFloat,\n  isInteger,\n  isNumber,\n  round,\n  RoundingMode,\n  toInteger,\n  toIntegerOrThrow,\n  toNumber,\n  toNumberOrThrow,\n};\n"],"names":["RoundingMode","toNumber","input","options","_options$roundingMode","_options$digits","roundingMode","NONE","digits","cast","isNumber","parseFloat","String","FLOOR","floor","CEIL","ceil","ROUND","round","toNumberOrThrow","result","TypeError","num","factor","Math","pow","value","Number","isFinite","isInteger"],"mappings":"AAQA,IAAKA,EAAAA,QAAAA,kBAAAA,GAAAA,EAAAA,QAAYA,eAAZA,QAAYA,aAKhB,CAAA,IAJC,KAAA,OACAA,EAAA,MAAA,QACAA,EAAA,KAAA,OACAA,EAAA,MAAA,QAQI,IAAAC,EAAW,SACfC,EACAC,GACEC,IAAAA,EAAAC,EACIC,EAAoC,OAAxBF,EAAU,MAAPD,OAAO,EAAPA,EAASG,cAAYF,EAAIJ,QAAAA,aAAaO,KACrDC,EAAwBH,OAAlBA,EAAGF,MAAAA,OAAAA,EAAAA,EAASK,QAAMH,EAAI,EAE5BI,EAAOC,EAASR,GAASA,EAAQS,WAAWC,OAAOV,IAEzD,IAAIQ,EAASD,GAYX,OAAO,KAXP,OAAQH,GACN,KAAKN,QAAAA,aAAaa,MAChB,OAAOC,EAAML,EAAM,CAAED,OAAAA,IACvB,KAAKR,QAAYA,aAACe,KAChB,OAAOC,EAAKP,EAAM,CAAED,OAAAA,IACtB,KAAKR,QAAAA,aAAaiB,MAChB,OAAOC,EAAMT,EAAM,CAAED,OAAAA,IACvB,QACE,OAAOC,EAKf,EAEMU,EAAkB,SACtBjB,EACAC,GAEA,IAAMiB,EAASnB,EAASC,EAAOC,GAE/B,GAAIO,EAASU,GACX,OAAOA,EAEP,MAAU,IAAAC,UAAS,kBAAmBnB,EAAK,cAE/C,EAmBMgB,EAAQ,SACZI,EACAnB,QAAA,IAAAA,IAAAA,EAA8B,CAAEK,OAAQ,IAExC,IAAMe,EAAMC,KAAAC,IAAG,GAAMtB,EAAQK,QAC7B,OAAOgB,KAAKN,MAAMI,EAAMC,GAAUA,CACpC,EAEMT,EAAQ,SACZQ,EACAnB,QAAA,IAAAA,IAAAA,EAA8B,CAAEK,OAAQ,IAExC,IAAMe,EAAMC,KAAAC,IAAG,GAAMtB,EAAQK,QAC7B,OAAOgB,KAAKV,MAAMQ,EAAMC,GAAUA,CACpC,EAEMP,EAAO,SACXM,EACAnB,QAAA,IAAAA,IAAAA,EAA8B,CAAEK,OAAQ,IAExC,IAAMe,EAAMC,KAAAC,IAAG,GAAMtB,EAAQK,QAC7B,OAAOgB,KAAKR,KAAKM,EAAMC,GAAUA,CACnC,EAgCMb,EAAW,SAACgB,SACC,iBAAVA,GAAsBC,OAAOC,SAASF,EAAM,iDAZrC,SAACA,GAAc,MACZ,iBAAVA,IAAuBC,OAAOE,UAAUH,EAAM,oBAZrC,SAACA,GAAc,MACd,iBAAVA,GAAsBC,OAAOE,UAAUH,EAAM,uDAlDpC,SAACxB,GACjB,OAAAD,EAASC,EAAO,CACdI,aAAcN,QAAYA,aAACa,OAC3B,2BAEqB,SAACX,GAAc,OACtCiB,EAAgBjB,EAAO,CACrBI,aAAcN,QAAAA,aAAaa,OAC3B"}