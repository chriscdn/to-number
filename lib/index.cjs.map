{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Enum representing the rounding mode for numeric conversions.\n *\n * @readonly\n * @enum {string}\n */\nenum RoundingMode {\n  NONE = \"none\",\n  FLOOR = \"floor\",\n  CEIL = \"ceil\",\n  ROUND = \"round\",\n}\n\n/**\n * Options for numeric conversion functions.\n *\n * @typedef {Object} Options\n * @property {RoundingMode} [roundingMode=RoundingMode.NONE] - Rounding mode to apply\n * @property {number} [digits=0] - Number of decimal digits to round to\n */\ntype Options = {\n  roundingMode?: RoundingMode;\n  digits?: number;\n};\n\n/**\n * Converts an unknown value to a numeric type (integer or float).\n *\n * Non-numeric strings, `NaN`, `Infinity`, and `-Infinity` are considered\n * non-numeric and return `null`.\n *\n * @param {unknown} input - The value to convert\n * @param {Options} [options] - Conversion options\n * @returns {number | null} The numeric value or null if conversion fails\n */\nconst toNumber = (\n  input: unknown,\n  options?: Options,\n) => {\n  const roundingMode = options?.roundingMode ?? RoundingMode.NONE;\n  const digits = options?.digits ?? 0;\n\n  const cast = isNumber(input) ? input : parseFloat(String(input));\n\n  if (isNumber(cast)) {\n    switch (roundingMode) {\n      case RoundingMode.FLOOR:\n        return floor(cast, { digits });\n      case RoundingMode.CEIL:\n        return ceil(cast, { digits });\n      case RoundingMode.ROUND:\n        return round(cast, { digits });\n      default:\n        return cast;\n    }\n  } else {\n    return null;\n  }\n};\n\n/**\n * Converts an unknown value to a numeric type and throws if conversion fails.\n *\n * @param {unknown} input - The value to convert\n * @param {Options} [options] - Conversion options\n * @returns {number} The numeric value\n * @throws {TypeError} If the value is NaN, Infinity, or cannot be parsed\n */\nconst toNumberOrThrow = (\n  input: unknown,\n  options?: Options,\n) => {\n  const result = toNumber(input, options);\n\n  if (isNumber(result)) {\n    return result;\n  } else {\n    throw new TypeError(`Cannot convert ${input} to number.`);\n  }\n};\n\n/**\n * Converts a value to an integer using floor rounding.\n *\n * @param {unknown} input - The value to convert\n * @returns {number | null} The integer value or null if conversion fails\n */\nconst toInteger = (input: unknown) =>\n  toNumber(input, {\n    roundingMode: RoundingMode.FLOOR,\n  });\n\n/**\n * Converts a value to an integer using floor rounding and throws if conversion fails.\n *\n * @param {unknown} input - The value to convert\n * @returns {number} The integer value\n * @throws {TypeError} If the value cannot be converted to a finite integer\n */\nconst toIntegerOrThrow = (input: unknown) =>\n  toNumberOrThrow(input, {\n    roundingMode: RoundingMode.FLOOR,\n  });\n\nconst withDecimalPrecision = (\n  num: number,\n  options: { digits: number },\n  func: (x: number) => number,\n): number => {\n  const { digits } = options;\n\n  if (digits === 0) {\n    return func(num);\n  } else if (isPositiveInteger(digits)) {\n    // A previous implementation would multiple by 10^digits, apply function\n    // (floor, ceil, round), and divide. While mathematically correct, it could\n    // introduce floating point errors. This approach gets around that.\n    //\n    // const factor = 10 ** options.digits; return Math.ceil(num * factor) /\n    // factor;\n    //\n\n    // shift the decimal to the right (e.g., 1.005 -> 100.5)\n    const shifted = toNumberOrThrow(`${num}e+${digits}`);\n\n    // round the shifted number (100.5 -> 101)\n    const rounded = func(shifted);\n\n    // shift the decimal back to the left (101 -> 1.01)\n    return toNumberOrThrow(`${rounded}e-${digits}`);\n  } else {\n    throw new Error(\"digits must be an integer greater than or equal to zero\");\n  }\n};\n\n/**\n * Rounds a floating-point number to the specified number of decimal digits.\n *\n * @param {number} num - The number to round\n * @param {Object} [options] - Options object specifying decimal digits\n * @param {number} [options.digits=0] - The number of decimal places\n * @returns {number} The rounded number\n */\nconst round = (\n  num: number,\n  options: { digits: number } = { digits: 0 },\n) => withDecimalPrecision(num, options, Math.round);\n\n/**\n * Floors a floating-point number to the specified number of decimal digits.\n *\n * @param {number} num - The number to floor\n * @param {Object} [options] - Options object specifying decimal digits\n * @param {number} [options.digits=0] - The number of decimal places\n * @returns {number} The floored number\n */\nconst floor = (\n  num: number,\n  options: { digits: number } = { digits: 0 },\n) => withDecimalPrecision(num, options, Math.floor);\n\n/**\n * Ceils a floating-point number to the specified number of decimal digits.\n *\n * @param {number} num - The number to ceil\n * @param {Object} [options] - Options object specifying decimal digits\n * @param {number} [options.digits=0] - The number of decimal places\n * @returns {number} The ceiled number\n */\nconst ceil = (\n  num: number,\n  options: { digits: number } = { digits: 0 },\n) => withDecimalPrecision(num, options, Math.ceil);\n\n/**\n * Checks if a value is a finite integer.\n *\n * @param {unknown} value - Value to check\n * @returns {value is number} True if value is a finite integer, false otherwise\n */\nconst isInteger = (value: unknown): value is number =>\n  typeof value === \"number\" && Number.isInteger(value);\n\n/**\n * Checks if a value is a finite and positive (>0) integer.\n *\n * @param {unknown} value - Value to check\n * @returns {value is number} True if value is a positive and finite integer, false otherwise\n */\nconst isPositiveInteger = (value: unknown): value is number =>\n  isInteger(value) && (value > 0);\n\n/**\n * Checks if a value is a finite non-integer number.\n *\n * @param {unknown} value - Value to check\n * @returns {value is number} True if value is a finite float, false otherwise\n *\n * removed - Why do we need this if we have isNumber() and isInteger() ?\n */\n\n//\n// const isFloat = (value: unknown): value is number =>\n//   typeof value === \"number\" && !Number.isInteger(value) &&\n//   Number.isFinite(value);\n\n/**\n * Checks if a value is a finite number (excludes NaN and Infinity).\n *\n * @param {unknown} value - Value to check\n * @returns {value is number} True if value is a finite number, false otherwise\n */\nconst isNumber = (value: unknown): value is number =>\n  typeof value === \"number\" && Number.isFinite(value);\n\nexport {\n  ceil,\n  floor,\n  isInteger,\n  isNumber,\n  isPositiveInteger,\n  round,\n  RoundingMode,\n  toInteger,\n  toIntegerOrThrow,\n  toNumber,\n  toNumberOrThrow,\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,IAAK,eAAL,kBAAKA,kBAAL;AACE,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,WAAQ;AAJL,SAAAA;AAAA,GAAA;AA6BL,IAAM,WAAW,CACf,OACA,YACG;AACH,QAAM,eAAe,SAAS,gBAAgB;AAC9C,QAAM,SAAS,SAAS,UAAU;AAElC,QAAM,OAAO,SAAS,KAAK,IAAI,QAAQ,WAAW,OAAO,KAAK,CAAC;AAE/D,MAAI,SAAS,IAAI,GAAG;AAClB,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,CAAC;AAAA,MAC/B,KAAK;AACH,eAAO,KAAK,MAAM,EAAE,OAAO,CAAC;AAAA,MAC9B,KAAK;AACH,eAAO,MAAM,MAAM,EAAE,OAAO,CAAC;AAAA,MAC/B;AACE,eAAO;AAAA,IACX;AAAA,EACF,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAUA,IAAM,kBAAkB,CACtB,OACA,YACG;AACH,QAAM,SAAS,SAAS,OAAO,OAAO;AAEtC,MAAI,SAAS,MAAM,GAAG;AACpB,WAAO;AAAA,EACT,OAAO;AACL,UAAM,IAAI,UAAU,kBAAkB,KAAK,aAAa;AAAA,EAC1D;AACF;AAQA,IAAM,YAAY,CAAC,UACjB,SAAS,OAAO;AAAA,EACd,cAAc;AAChB,CAAC;AASH,IAAM,mBAAmB,CAAC,UACxB,gBAAgB,OAAO;AAAA,EACrB,cAAc;AAChB,CAAC;AAEH,IAAM,uBAAuB,CAC3B,KACA,SACA,SACW;AACX,QAAM,EAAE,OAAO,IAAI;AAEnB,MAAI,WAAW,GAAG;AAChB,WAAO,KAAK,GAAG;AAAA,EACjB,WAAW,kBAAkB,MAAM,GAAG;AAUpC,UAAM,UAAU,gBAAgB,GAAG,GAAG,KAAK,MAAM,EAAE;AAGnD,UAAM,UAAU,KAAK,OAAO;AAG5B,WAAO,gBAAgB,GAAG,OAAO,KAAK,MAAM,EAAE;AAAA,EAChD,OAAO;AACL,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC3E;AACF;AAUA,IAAM,QAAQ,CACZ,KACA,UAA8B,EAAE,QAAQ,EAAE,MACvC,qBAAqB,KAAK,SAAS,KAAK,KAAK;AAUlD,IAAM,QAAQ,CACZ,KACA,UAA8B,EAAE,QAAQ,EAAE,MACvC,qBAAqB,KAAK,SAAS,KAAK,KAAK;AAUlD,IAAM,OAAO,CACX,KACA,UAA8B,EAAE,QAAQ,EAAE,MACvC,qBAAqB,KAAK,SAAS,KAAK,IAAI;AAQjD,IAAM,YAAY,CAAC,UACjB,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK;AAQrD,IAAM,oBAAoB,CAAC,UACzB,UAAU,KAAK,KAAM,QAAQ;AAsB/B,IAAM,WAAW,CAAC,UAChB,OAAO,UAAU,YAAY,OAAO,SAAS,KAAK;","names":["RoundingMode"]}